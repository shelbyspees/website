---
title: "Code is like clay"
slug: code-is-like-clay
date: 2021-06-16T09:39:45-07:00
draft: true
images:
tags:
  - software
  - complex systems
  - learning
---

I recently thought of this metaphor and I'm pretty proud of it üòÖ:

Code is like clay.
The goal is to never let it harden.

<!-- more -->

GitHub has the idea of stale branches.
Detectives and hunters might say that a trail went cold.

## I'm not original

I'm not the first person to compare code to clay.
A cursory Google got me this:

<!-- Code is like clay; never be afraid to scrunch it into a ball and start afresh. -->
{{% tweet 900904407189082116 %}}

In this case the point is that it's essentially free to throw out your code and start over
because changing and rewriting a chunk of code is cheaper than
an equivalent change would be on anything that requires physical materials.

While this is trivially true, I don't think it applies to most of the code we care about
because code we care about almost universally lives in a complex system.
Even with the best possible design with the strictest separation of concerns,
[changes to code within a complex system
can have unintended and unpredictable ripple effects](https://how.complexsystems.fail).

On a more practical level:
how often are software teams given the space to do a complete rewrite of a component?

Another use of the metaphor is this
[blog post from 2017](https://www.upbeat.it/programming-languages-and-clay/).
that uses the clay-hardening metaphor for frameworks
(note: the post quotes [Robert Martin](),
someone I don't exactly want to promote).


I also discovered a [startup in Brooklyn called Clay](https://www.clay.run).




## Why not let it harden?

Metaphors break down quickly, like a brick that wasn't fired properly üòú

(Okay so I actually looked up what happens when bricks aren't fired.
There's actually a whole type of masonry that uses air-dried bricks,
which makes perfect sense considering that
that's how many buildings have been constructed throughout history.
I even found [this article](https://www.greenspec.co.uk/building-design/unfired-clay-bricks/)
describing how unfired clay bricks can be used in environmentally-friendly building design.
Pretty neat.)

Once your code becomes load-bearing,
it's no longer a stand-alone artifact.
It's part of (what I consider to be) a living, breathing system.

Your system isn't just the software running on servers.
Your system includes all the people who interact with it:
developers, testers, operators, users, support teams.

Your system is messy and complex and constantly changing,
even when your code doesn't change.

And since we can never have perfect mental models of our complex systems,
the next best thing is to continuously update our imperfect mental models.

There are many ways to do so, and the [Learning From Incidents community]()
is a great resource to learn from about the topic.
What I'm proposing is a baby-steps approach.

<!-- Many people's notion of learning is that it is very structured. -->
{{% tweet 1405227795287089158 %}}

Constantly adjusting our understanding.
Constantly learning.



When we treat out code like clay that we want to stay pliable,








## Not just code

I was hesitant to use "code" in the metaphor.
The catchiness of won me over.



## Hooray for clay

Now I'm going to share the different types of clay
I was thinking about while writing this post üòÅ
